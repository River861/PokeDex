<center style="font-size:30px;">基于框架和规则的Pokémon识别专家系统</center><br><br>
<center>姓名： 罗旭川  &nbsp;&nbsp;&nbsp;&nbsp; 学号：17307130162</center><br>
**概要：**动物识别专家系统是一种典型的专家系统，它是通过用户描述一种动物的多个特征，然后由专家系统推测出该动物的种类。而本项目依据的是同样的思路，但是将对象转向了一类虚拟的物种——宝可梦(Pokémon)。通过用户描述一种宝可梦的多个特征，本专家系统将推测出具体的宝可梦种类。在实现方面，本项目是基于框架的专家系统，同时运用了基于规则的专家系统中的不确定性管理方法，还运用了决策树模型的ID3算法优化了用户交互体验。利用框架的特性，本项目实现了知识库的动态生成；利用问题的缺省结构设计，本项目实现了问题集的动态生成；利用确性因子和ID3算法，本项目实现了问题的动态选择。同时，本专家系统还包含了解释设备以及特征库的扩展接口。



**关键词：**基于框架的专家系统；不确定性管理；ID3算法；动态生成；动态选择；宝可梦









<center style="font-size:25px;">Frame-based and Rule-based Pokémon<br><br>Recognition Expert System</center><br><br>
<center>Luo Xuchuan  &nbsp;&nbsp;&nbsp;&nbsp; 17307130162</center><br>
Abstract: The animal recognition expert system is a typical expert system. It speculates the type of an animal with features of the animal provided by the user. Based on the same idea, this project turned the research object to Pokémon, a virtual species. It speculates the type of a Pokémon with features provided by the user. In terms of implementation, this project is a frame-based expert system, using the uncertainty management of the rule-based expert system, as well as the ID3 algorithm of the decision tree model to optimize the user interaction experience. With the characteristics of the frame-based expert system, this project realized the dynamic generation of the knowledge base. With incomplete problem structures, this project realized the dynamic generation of the problem set. With the certainty factor and ID3 algorithm, this project realized the dynamic selection of the problems from the problem set. In addition, this expert system also includes an explanation facility and an extended interface of the feature database.



Key words: frame-based expert system;  uncertainty management;  ID3 algorithm;  dynamic generation;  dynamic selection;  Pokémon











<center style="font-size:25px;">目录</center><br><br><br>
0  项目研究现状与背景 ......................................................................................................................... 3

1  架构设计 ........................................................................................................................................... 3

2  具体实现 ........................................................................................................................................... 4

​     2.1  特征数据库建立 ......................................................................................................................... 4

​     2.2  问题设计 .................................................................................................................................... 5

​     2.3  框架设计 .................................................................................................................................... 7

​              2.3.1 为什么选择基于框架的专家系统设计？ ............................................................................ 7

​              2.3.2 定义类及其属性 ................................................................................................................ 8

​              2.3.3 定义守护程序 ................................................................................................................... 8

​     2.4  规则设计 .................................................................................................................................... 9

​              2.4.1 为什么选择基于确信因子的规则设计？ ............................................................................ 9

​              2.4.2 不确定性规则的动态生成 .................................................................................................. 9

​              2.4.3 确信度的更新 ................................................................................................................... 12

​              2.4.4 其它规则 .......................................................................................................................... 13

​     2.5 通过决策树ID3算法实现问题动态选择 ....................................................................................... 13

​              2.5.1 为什么选择ID3算法？ ...................................................................................................... 13

​              2.5.2 ID3算法在本项目的应用 .................................................................................................. 14

3  模拟实验 .......................................................................................................................................... 15

4  其它实现细节 ................................................................................................................................... 17

5  效果展示 .......................................................................................................................................... 17

6  总结 ................................................................................................................................................. 19

7  参考文献 .......................................................................................................................................... 20















## 0  项目研究现状与背景

<img src="/home/river/桌面/Pokemon-Map/report/动物识别.jpg"  />

​                                                                         (图0.1  图片来自参考文献[1])

​         本项目的灵感来源于动物识别系统。         

​         在当前，随着深度学习的不断发展，动物识别已经可以通过图像识别的技术得到较好的实现。而在早期，动物识别主要通过基于产生式规则的专家系统实现，但受到动物物种丰富度的影响，规则知识库大小的限制和问题种数的限制，动物识别专家系统并不能很好地得到发展和应用。

<img src="/home/river/桌面/Pokemon-Map/report/图鉴-1.jpeg" style="zoom:100%;" />             <img src="/home/river/桌面/Pokemon-Map/report/图鉴1.jpg" style="zoom:25%;" />

​                                  （图0.2）                                                                                       （图0.3）

​         精灵宝可梦(Pokémon)，又称口袋妖怪、宠物小精灵（方便起见，后文统一称为宝可梦或pokemon），是由任天堂游戏创造、在日本动画中出现的虚拟生物，在一部分人群中很受欢迎。而宝可梦图鉴，则是一种用来记录、识别宝可梦信息的设备。如图0.2、0.3所示，宝可梦图鉴通过摄像头扫描宝可梦，该设备即可识别出该宝可梦的具体信息和数据。这十分类似于现实中的基于神经网络的图像识别技术。

​         本项目实现的专家系统即是以宝可梦图鉴为原型设计的。但不是使用摄像头和图像识别技术来提取特征，本项目是一个基于问答来收集特征的专家系统。系统向用户提出问题，然后根据用户的回答来推测和识别用户所描述的宝可梦类型。相比于真实生活中的动物，宝可梦具有物种种类少、不同物种之间特征差异明显等特征，因此非常适合通过针对小范围领域的专家系统来实现。另外，针对传统的动物识别专家系统规则知识库大小和问题种数上的受限问题，本项目考虑通过规则知识库和问题的动态生成来提升专家系统性能。





## 1  架构设计

<img src="/home/river/桌面/Pokemon-Map/report/架构图.png" style="zoom: 25%;" />

​         本项目中的知识库、问题集是由外部的pokemon特征数据库自动生成的，具体在之后会讲。开发人员（专家或知识工程师）可以通过开发人员界面修改pokemon特征数据库。由于知识库、问题集是由特征数据库生成的，因此开发人员的修改实际上将更新知识库中的规则、更新问题集。 

​         系统首先从问题集中挑选最有效的问题，然后通过用户界面的显示设备向用户进行特征询问，用户回答询问并通过用户界面的输入设备输入答案。用户的回答将作为事实储存在事实库中。推理引擎随后根据事实库中的事实，在知识库中寻找匹配的规则前项，然后执行相应规则的后项，执行的规则后项会更新每一种宝可梦成为答案的确信度，然后推理引擎继续从问题集中动态挑选问题并向用户进行新一轮的询问。

   	  在执行了若干轮问答后，推理引擎取得了足够的特征后，会将确信度最大的pokemon作为答案交给用户界面的解释设备。解释设备将答案和推理轨迹在显示设备上显示出来以此使得用户可见。

​         本项目将问答轮数上限设置为了10，也就是系统将在小于等于10轮的问答内给出答案。注意在本系统中，每一轮的问答提出的问题均为是非判断题，而不是需要用户进行详细回答的问题，因此10轮的问答上限是合理的。用户基本上在半分钟左右可以完成一次pokemon识别。

​        用户可以对结果进行评判，当推测结果被否认后，解释设备可以将下一个确信度最大的pokemon及其推理轨迹显示出来，用户继续进行评判，以此类推，直至用户确认答案或候选pokemon被全部否认。

​		 本专家系统最终通过python 3.6 以及通过 PyQt5 进行界面设计来实现。





## 2  具体实现

### 2.1  特征数据库建立

* 数据来源

​         在本项目中，我将作为宝可梦领域的专家建立pokemon特征数据库，从而生成知识库。数据方面参考了宝可梦百科（参考文献[3]）。最终一共添加了73只宝可梦的特征数据到数据库中。数据库中分为子类表和父类表两个表，子类表存储宝可梦中每一物种的特征，父类表存储宝可梦的每一类群的特征。

* 子类表

  ​                      <img src="/home/river/桌面/Pokemon-Map/report/杰尼龟.png" style="zoom:10%;" />                      <img src="/home/river/桌面/Pokemon-Map/report/皮卡丘图.png" style="zoom:10%;" /> 

  ​                      (图2.1.1  杰尼龟)                           （图2.1.2  皮卡丘）

  ![](/home/river/桌面/Pokemon-Map/report/数据库.png)

  ​         子类表存储了以上属性。super_class属性指明了该宝可梦的父类名称。这是为之后框架的继承做准备。

  ​         当一个属性的值为NULL时，代表该宝可梦没有这一项特征或这一项特征将从父类继承。比如第一个宝可梦杰尼龟（如图2.1.1），它没有耳朵，并且它的父类龟类也没有耳朵这一特征，因此最终它将没有耳朵颜色这一特征。

  ​         当一个属性拥有多个值时，我们将它们用空格隔开存放，并规定将占比越大的值排在越前面。比如皮卡丘（如图2.1.2）的耳朵大部分为黄色，小部分为黑色，因此我们排列为“黄色 黑色”；又比如皮卡丘大部分栖息在森林中，小部分栖息在城市中，因为我们将栖息地属性的值排列为“森林 城市”。这样排列是为之后的不确定性管理做准备。

* 父类表

  <img src="/home/river/桌面/Pokemon-Map/report/父类表.png" style="zoom:80%;" />

  ​         父类表存放了宝可梦父类的特征信息。比如蛇类一般没有四肢也没有翅膀，所以蛇类的手脚个数和翅膀个数属性都是0，并且蛇类宝可梦一般具有 “像一条蛇”的特征，因此细节属性上存放了这一特征描述。具体的继承相关的规则我们将在框架设计时细讲。

  


### 2.2  问题设计

* 设计目标

  对于问题的设计，我们希望设计出的问题能够具有以下特点：

  * 高区分性。即问题的回答能够尽可能好地区分出不同的宝可梦。
  * 易答性。即用户能有轻松地作出清晰或模糊的回答，比如是、不是、好像是、好像不是等等。这样的目的是为了提高用户体验。

  

* 设计方案

  最终根据设计目标和数据库中已有的特征类型，我设计出了以下7类问题：
  
  ![](/home/river/桌面/Pokemon-Map/report/questions.png)
  
  ​        我们可以看到，上述设计的问题不仅具有高区分性，并且用户能够仅仅通过简单的是非判断来进行轻松的回答。 问题的样式使用了缺省的结构设计。
  
  
  
* 问题实例的动态生成

  ​         通过问题的缺省结构来设计问题，是为了实现问题的动态生成。

  ```python
  val_box = {
      'color': set(),
      'eye_color': set(),
      'ear_color': set(),
      'limb_num': set(),
      'wing_num': set(),
      'habitat': set(),
      'detail': set(),
  }
  question_box = {
      'color': '它的身体是不是有{val}的部分？',
      'eye_color': '它的眼睛是{val}的吗？',
      'ear_color': '它的耳朵是{val}的吗？',
      'limb_num': '它一共有{val}只手和脚吗？',
      'wing_num': '它是不是有{val}只翅膀？',
      'habitat': '它是不是生活在{val}附近？',
      'detail': '它是不是{val}？',
  }
  ```

  ​         问题的动态生成，具体而言，即系统通过维护了一个问题样式集question_box和一个特征值集val_box来动态生成问题实例集合。当系统启动时，会加载特征数据库中所有宝可梦的特征，然后将特征值收集在val_box中，之后由question_box和val_box进行对应组合来生成问题实例集合。

  ​         一方面，缺省的问题结构极大地增加了问题的多样性，每一个具体的特征都将对应于一个具体的问题；另一方面，事实上缺省的问题结构对于知识库的扩充是必要的：当专家或知识工程师新增或修改pokemon特征数据库时，为了通过新特征来区分出新的宝可梦，系统将需要依照问题的样式生成相应的新的问题实例。

  ​         目前，在数据库中已有的73只宝可梦中，各种类型的特征值数量如下：

  <img src="/home/river/桌面/Pokemon-Map/report/特征数.png" />
  
  因此问题实例个数总共为133个。



### 2.3  框架设计



<img src="/home/river/桌面/Pokemon-Map/report/框架图.png" style="zoom: 50%;" />

#### 2.3.1 为什么选择基于框架的专家系统设计？

  ​       基于框架的专家系统允许宝可梦特征的缺省输入。比如当输入皮卡丘的特征到系统中时，并不需要提供皮卡丘的手脚个数和翅膀个数，因为这两个特征可以由其父类直接继承而来；另外，当修改某一父类的特征时，就能将所有子类的缺省特征一并修改，这样十分便于数据的修改。

  ​       基于框架的专家系统的精髓在于它可以实现缺省推理。在宝可梦识别的任务中，系统需要通过用户提供的有限的特征来确定宝可梦的种类，这就需要借助专家系统的缺省推理能力。比如，当用户提供了“整体呈黄色”和“有像锯齿状闪电的尾巴”这两个特征，并且系统发现除了皮卡丘外再没有第二个宝可梦同时具有这两个特征时，系统就应该直接给出皮卡丘这一答案。而不再需要用户继续提供眼睛颜色、耳朵颜色等其他特征了，因为这些特征已经被系统缺省推理出来了。

#### 2.3.2 定义类及其属性

​         上图所示为本项目中定义的框架局部图。首先宝可梦类会泛化为蛇类、虫类、鸟类、犬类、鼠类等多个类别，然后这里的每种类别又会继续泛化为各种不同种的宝可梦。这里以鼠类为例，鼠类宝可梦泛化为了皮卡丘、电飞鼠等具体的鼠类宝可梦。然后每一种宝可梦就会产生相应的实例。

​         子类可以继承父类的特征，比如上图中皮卡丘继承了鼠类的4个手脚和0个翅膀的特征；子类又可以覆盖父类的特征，形成自己独特的特征，比如电飞鼠的翅膀数为2，覆盖了父类的0个翅膀的特征。

​         宝可梦的每一个特征都被作为槽值添加到了相应的类框架中。除此之外，框架中还增添了一个叫确信度的槽值。这个槽值维护了当前该宝可梦为最终答案的确信度。当推理引擎根据规则进行推理时，会改变每一种宝可梦的确信度，最终确信度最高的宝可梦会作为答案输出。确信度初始值为0。

​         利用python的面向对象程序设计可以很方便的实现上述框架：

```python
class Pokemon:

    def __init__(self, name, url, height, weight, intro):
        '''框架的所有槽值
        '''
        self.cf = 0.0 # 确信度
        self.name = name
        self.height = height
        self.weight = weight
        self.slot = {
            'color': dict(),
            'eye_color': dict(),
            'ear_color': dict(),
            'limb_num': dict(),
            'wing_num': dict(),
            'habitat': dict(),
            'detail': dict(),
        }
        ......
```

​         实现分两步，先从前面提到的pokemon特征数据库中读取父类表的信息，将父类信息导入到相应的上述子类宝可梦类中；然后再读取数据库中子类表的信息，直接导入相应的宝可梦类中。这样就能实现子类对父类的继承和覆盖。

#### 2.3.3 定义守护程序

​         为了提高专家系统的识别效率，本系统设置了一个守护程序来排除不可能的宝可梦。被排除的宝可梦将不会参与之后的判断。我将该守护程序附加在了每种宝可梦的确信度槽上。当每一轮问答结束时，系统会对候选列表中的所有宝可梦的确信度进行更新。当每个宝可梦的确信度改变时，会触发这个守护程序，守护程序将判断该宝可梦是否已经可以排除，若可以，则将其从候选列表中删除。

```python
    def update_cf(self, key, val, cf) :
        # 更新cf值
		......
        if self.cf < 0.5:
            self.false_cnt += 1
            
    def is_out(self) :
        if self.false_cnt > 2 :
            return True
        return False
```

​         上述守护程序的意思是，当一个宝可梦在3轮的问答中确信度在0.5以下，则将其标记为is_out，即从候选中排除。



### 2.4  规则设计

![](/home/river/桌面/Pokemon-Map/report/cf.png)

<center>（表2.4.1  数据源于课本第3章）<center>

#### 2.4.1 为什么选择基于确信因子的规则设计？

​         确信因子技术是常用的代替贝叶斯推理的方法。由于在宝可梦识别的过程中，由一种特征推出一个宝可梦的概率是困难的，或者说是没有数学依据的，因此我们考虑使用确信因子来推理宝可梦的种类。在本专家系统中，将由我作为宝可梦领域的专家，根据自己的知识来确定规则和确信因子。

​          本项目中确信因子的具体数值主要是通过自己的判断结合教材的不确定性术语表（表2.4.1）来确定的。

#### 2.4.2 不确定性规则的动态生成

​         前面我们提到过，本项目中的知识库是由pokemon特征数据库动态生成的，这实际上是因为，宝可梦的特征隐式地表达了宝可梦的识别规则。本系统将分别从框架中导出正向规则、反向规则以及缺失规则。

​         下面以杰尼龟为例介绍这三种规则是如何导出的。下面框架展示出的为杰尼龟框架中用于产生规则的那一部分槽值，我们前面设计的问题正是与这些槽值有关的问题：

​                            <img src="/home/river/桌面/Pokemon-Map/report/杰尼龟框架.png" style="zoom:85%;" />    <img src="/home/river/桌面/Pokemon-Map/report/杰尼龟.png" style="zoom:18%;" />

* 由框架直接导出正向规则

  ```
  Rule 1: IF 整体颜色 is 蓝色                    Rule 2: IF 整体颜色 is 蓝色
          AND cf_user >= 0                               AND cf_user < 0
          THEN 答案 is 杰尼龟 {0.4}                      THEN 答案 is 杰尼龟 {0.7}
  Rule 3: IF 整体颜色 is 黄色                    Rule 4: IF 整体颜色 is 黄色
          AND cf_user >= 0                               AND cf_user < 0
          THEN 答案 is 杰尼龟 {0.3}                      THEN 答案 is 杰尼龟 {0.6}
  Rule 5: IF 整体颜色 is 褐色                    Rule 6: IF 整体颜色 is 褐色
          AND cf_user >= 0                               AND cf_user < 0
          THEN 答案 is 杰尼龟 {0.2}                      THEN 答案 is 杰尼龟 {0.5}
  Rule 7: IF 眼睛颜色 is 紫色                    Rule 8: IF 眼睛颜色 is 紫色
          AND cf_user >= 0                               AND cf_user < 0
          THEN 答案 is 杰尼龟 {0.4}                      THEN 答案 is 杰尼龟 {0.7}
  Rule 9: IF 眼睛颜色 is 黑色                    Rule 10: IF 眼睛颜色 is 黑色
          AND cf_user >= 0                                AND cf_user < 0
          THEN 答案 is 杰尼龟 {0.3}                       THEN 答案 is 杰尼龟 {0.6}
  Rule 11: IF 手脚个数 is 4                      Rule 12: IF 手脚个数 is 4
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {0.4}                      THEN 答案 is 杰尼龟 {0.7}
  Rule 13: IF 翅膀个数 is 0                      Rule 14: IF 翅膀个数 is 0
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {0.4}                      THEN 答案 is 杰尼龟 {0.7}
  Rule 15: IF 栖息地 is 湖泊                     Rule 16: IF 栖息地 is 湖泊
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {0.4}                      THEN 答案 is 杰尼龟 {0.7}
  Rule 17: IF 栖息地 is 海边                     Rule 18: IF 栖息地 is 海边
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {0.3}                      THEN 答案 is 杰尼龟 {0.6}
  Rule 19: IF 细节 is 有着波浪形的尾巴
           THEN 答案 is 杰尼龟 {0.9}
  ```

  正向规则是显然的，但是我们还是需要对确信度的赋值进行如下细致、合理的考虑：

  * 为用户肯定与否定情况给予不同的确信度增益或惩罚

    ​         当用户对上述符合杰尼龟特征的前项给予肯定（用户输入确信度 $cf_{user}>=0$）时，答案为杰尼龟的确信度就应该较少地增加（这里设为0.2~0.4）；当用户对上述符合杰尼龟特征的前项给予否定（用户输入确信度 $cf_{user}<0$）时，答案为杰尼龟的确信度就应该较多地减少（这里设为0.5~0.7）。这是容易理解的，比如，当用户肯定颜色是蓝色时，因为可能还有其他宝可梦也是蓝色的，因此依然不能非常确定为杰尼龟；当用户否定颜色是蓝色时，因为杰尼龟就是蓝色的，因此答案是杰尼龟的可能性就大大降低了。

  * 为同一特征的不同特征值基于不同的确信度增益或惩罚

    ​         我们前面提到过，在数据库中，当一个特征拥有多个值时，我们规定了要将这多个值按照占比大小排序。

    ​         对于占比大的特征值的“命中”，我给予了较多确信度增益或惩罚（这里为0.4、0.7）；对于占比小的特征我则给予相对较少的确信度增益或惩罚（这里为0.2或0.3、0.5或0.6）。比如，杰尼龟大部分栖息在湖泊，而小部分是栖息在海边的，当用户肯定栖息地为湖泊的事实时，我们应该给予更多的确信度增益0.4或0.7；而相比之下，当用户肯定栖息地为海边的事实时，我们应该给予相对少一点的确信度增益0.3或0.6。对于其它特征以及否定的情形与此类似。

  * 对于“细节”特征，给予尽量重的确信度增益或惩罚

    ​         对于细节特征，我直接给予了0.9的确信度增益或惩罚。因为细节特征几乎是一个宝可梦定义性的特征。比如“有着波浪形的尾巴”的宝可梦几乎能直接确定是杰尼龟了；而当用户否定了这一特征时，就几乎能排除杰尼龟了。

* 由框架缺省推理出反向规则

  ```
  Rule 20: IF (整体颜色 is 黑色                  Rule 21: IF (整体颜色 is 黑色
           OR  整体颜色 is 白色                           OR  整体颜色 is 白色
               ......)                                        ......)
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {- 0.7}                    THEN 答案 is 杰尼龟 {- 0.3}
  Rule 22: IF (眼睛颜色 is 黄色                  Rule 23: IF (眼睛颜色 is 黄色
           OR  眼睛颜色 is 红色                           OR  眼睛颜色 is 红色
               ......)                                         ......)
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {- 0.7}                    THEN 答案 is 杰尼龟 {- 0.3}
  Rule 24: IF (手脚个数 is 0                     Rule 25: IF (手脚个数 is 0
           OR  手脚个数 is 2                              OR  手脚个数 is 2
               ......)                                         ......)
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {- 0.7}                    THEN 答案 is 杰尼龟 {- 0.3}
  Rule 26: IF (翅膀个数 is 2                     Rule 27: IF (翅膀个数 is 2
           OR  翅膀个数 is 4                              OR  翅膀个数 is 4
               ......)                                         ......)
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {- 0.7}                    THEN 答案 is 杰尼龟 {- 0.3}
  Rule 28: IF (栖息地 is 森林                    Rule 29: IF (栖息地 is 森林
           OR  栖息地 is 城市                             OR  栖息地 is 城市
               ......)                                         ......)
           AND cf_user >= 0                               AND cf_user < 0
           THEN 答案 is 杰尼龟 {- 0.7}                    THEN 答案 is 杰尼龟 {- 0.3}
  Rule 30: IF (细节 is 有像锯齿状闪电的尾巴       Rule 31: IF (细节 is 有像锯齿状闪电的尾巴
           OR  细节 is 尾巴上有火焰在燃烧                  OR  细节 is 尾巴上有火焰在燃烧
               ......)                                         ......)
           AND cf_user >= 0                               AND cf_user < 0
         THEN 答案 is 杰尼龟 {- 1.0}                    THEN 答案 is 杰尼龟 {0.0}
  ```

  反向规则是容易遗漏的。并且我们依然需要对确信度的赋值进行如下细致、合理的考虑：

  * 为用户肯定与否定情况给予不同的确信度增益或惩罚
  
    ​        当用户对上述不符合杰尼龟特征的前项给予肯定（用户输入确信度 $cf_{user}>=0$）时，答案为杰尼龟的确信度就应该较多地减少（这里设为-0.7）；当用户对上述不符合杰尼龟特征的前项给予否定（用户输入确信度 $cf_{user}<0$）时，答案为杰尼龟的确信度就应该较少地增加（这里设为-0.3）。这也是容易理解的，比如，当用户肯定颜色是白色时，因为杰尼龟根本不是白色的，因此答案是杰尼龟的可能性就大大降低了；当用户否定颜色是白色时，虽然杰尼龟的确不是白色的，但是有许多其他宝可梦也不是白色的，因此答案依然不能十分确定为杰尼龟。
  
  * 对于“细节”特征，分别给予最重或最轻的确信度增益或惩罚
  
    ​        这里与正向规则有所不同。我对用户肯定的、不符合杰尼龟的细节特征给予了-1.0的确信度惩罚；而对用户否定的、不符合杰尼龟的细节特征给予了0，即不增益也不惩罚。这是合理的，比如“尾巴上有火焰在燃烧”的宝可梦几乎能直接排除杰尼龟了；而当用户否定了这一特征时，由于绝大部分宝可梦都不具有“尾巴上有火焰在燃烧”的细节特征，因此这一轮问答基本可以认为是无效问答。

* 由框架导出缺失规则

  ```
  Rule 32: IF 耳朵颜色 is 黑色
           OR 耳朵颜色 is 黄色
              ......
           THEN 答案 is 杰尼龟 {0.0}
  ```

  ​         由于我们前面提到，杰尼龟没有耳朵，即它的耳朵颜色值为NULL，我将这种情况的确信度增益和惩罚设置为0，即不增益也不惩罚。因为这样的问题是无意义的。当用户针对一只没有耳朵的宝可梦回答与“耳朵颜色”相关的问题时，用户回答是也不对，回答不是也不对，因此我们需要将这种问题的回答直接无视掉。

​         以上我一共由杰尼龟的框架中推导出了32条规则。在本项目中，专家系统将自动对所有的宝可梦框架都进行类似的规则导出。如果按一个框架平均推出30条规则来计算，本系统一共隐式地包含了30*73=2190条规则。可以看出，在本系统中，知识库的丰富度是比较可观的了。

​         逐条设计和输入2190条规则是不容易的，而通过框架的缺省特性就可以简单快速地生成这么多条规则，这就是本系统中规则动态生成方法的优越之处。同时，“动态”生成还体现在专家和知识工程师只需要通过修改或增添pokemon特征库就可以实现对知识库中大量规则的修改和增添。

#### 2.4.3 确信度的更新

每一轮的问答都会更新所有宝可梦的确信度。实际上确信度的更新是通过旧确信度和新确信度的合并来实现的。

* 旧确信度 $cf$ 是指在进行本轮问答之前宝可梦框架中的确信度槽值；

* 新确信度 $cf_{new}$ 是指 本轮问答后得到的事实 经过上述不确定性规则计算得出的该宝可梦的新确信度。
  $$
  cf_{new}=cf_{user}\cdot cf_{rule}
  $$
  例如，对于以下规则：

  ```
  Rule 1: IF 整体颜色 is 黄色
          THEN 答案 is 皮卡丘 {0.4}
  ```

  若用户给出的对于整体颜色为黄色的确信度 $cf_{user}$ 为0.6，则皮卡丘的新确信度$cf_{new}=0.6\times 0.4=0.24$

确信度的合并运用的是教材中确信因子的合并公式：
$$
cf = merge(cf, cf_{new})
$$

$$
merge(cf1, cf2)=
\begin{cases}
cf1 + cf2(1-cf1), \ \ \ \ \ \ \ \ \  cf1>0\ and\ cf2>0 \\
cf1 + cf2(1+cf1), \ \ \ \ \ \ \ \ \ cf1<0\ and\ cf2<0 \\
\frac{cf1+cf2}{1-min(|cf1|, |cf2|)},\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else 
\end{cases}
$$

例如，若皮卡丘的旧确信度 $cf$ 为0.5，则最终确信度更新为 $cf = 0.5+0.24(1-0.5)=0.65$，确信度得到了提升。

#### 2.4.4 其它规则

其它规则指的是最终确定答案时要使用的一些确定性的规则，具体如下：

* 询问结束规则

  ​         当候选宝可梦数量≤1或者问答的轮数≥10时，停止询问。

  ```python
      def enough(self, turn_num):
          '''结束条件
          '''
          return len(self.pokemons) <= 1 or turn_num >= 10
  ```

  ​         我们前面提到过，附加在确信度槽值上的守护程序每轮都会进行检查，并将那些不可能的宝可梦从候选列表中删除，因此当候选列表只剩下一个候选宝可梦时，我们实际上已经得到答案了。另一方面，当问答轮数已经超过了10轮，我们则可以认为特征事实已经收集充分了，接下来将选取确信度最大的作为答案。

* 最终决策规则 和 候补规则

  ​         当询问停止后，选取确信度最大的宝可梦作为答案输出；若答案被用户否认，则选取下一个最大的宝可梦作为答案输出，以此类推，直至所有候选宝可梦均被否认。

  ```python
      def get_ans_list(self):
          '''获取结果列表 按可能性从大到小排列
  
          每个结果包含四元组(cf, name, 身高, 体重, 简介)
          '''
          ans, cf = None, 0
          cf_list = list()
          for poke in self.pokemons.values():
              cf_list.append((poke.cf, poke.name, poke.url, poke.height, poke.weight, poke.intro))
              if poke.cf > cf:
                  ans = poke
                  cf = poke.cf
          return sorted(cf_list, key=lambda x:x[0], reverse=True)
  ```

  ​        在python实现中，当询问停止后，直接获取剩余的整个候选列表，并将其按确信度从大到小排列，将最大的作为答案输出。若答案被用户否定，则在列表中删除该宝可梦，选择下一个确信度最大的宝可梦输出。这样实际上是为本专家系统提供了一个容错性，这样的容错机制在一定程度上也能提高用户体验。

  

### 2.5 通过决策树ID3算法实现问题动态选择

​        前面提到，本系统中已经动态生成的问题实例个数共有133个，我们不可能让用户按顺序回答完全部的问题，因此我们需要从中挑选出最有效的问题来进行询问。而由于宝可梦的确信度在每一轮问答后都会发生改变，因此最有效的问题在不同的轮数中是会变化的，因此我们需要找到一种方法来动态找出每一轮的当前最有效问题。而如何定义什么是“最有效”的问题呢？这里我们将信息熵作为评判标准，运用的是决策树ID3算法的思想。

#### 2.5.1 为什么选择ID3算法？

​         ID3算法是一种用来生成决策树的贪心算法。它通过计算一个集合中每种属性的信息增益，然后选取信息增益最大的属性作为划分标准来划分集合。以此类推，最终将集合划分成一个能完美分类元素的决策树。我们可以看到，ID3算法最大化了信息增益，而我们在选择进行询问的问题时，正是希望能选择最大化信息增益的问题进行询问，以此加快宝可梦的筛选。因此用ID3算法来实现对下一个询问问题的动态选择是非常合适的。ID3算法公式如下：

* 设S为一个集合，它根据一个目标属性的值分为n个子集，则S的信息熵为：
  $$
  E(S)=-\sum^{n}_{i=1}p_ilog_2p_i
  $$
  其中，$p_i$为第i个子集对应的目标属性值的概率。

  信息熵越小表示在集合S中该目标属性的值的分布越纯，即越稳定。

* 设一个非目标属性A将S划分为了m个子集，则S的信息熵变为：
  $$
  E_A(S)=\sum^{m}_{j=1}\frac{|S_j|}{|S|}E(S_j)
  $$
  这里实际上就是通过计算加权平均值来求得信息熵期望。

* 信息增益是划分前集合的不纯程度和划分后集合的不纯程度的差值，即信息熵之差：
  $$
  Gain(S, A)=E(S)-E_A(S)
  $$
  我们的目标即为找到一个非目标属性A来使得 $Gain(S, A)$ 最大，从而使得根据属性A划分后的集合分布尽可能的纯，也就是尽可能的稳定。


#### 2.5.2 ID3算法在本项目的应用

* 问题分析

  ​         我们的目标是从133个问题中选取一个使得候选宝可梦集合信息增益最大的问题，并将其作为下一个询问的问题。在每轮问答中，信息增益定义为 接收用户的回答之前 候选宝可梦集合的信息熵 与 接收回答后集合的信息熵 之差。由于对于每一个问题，回答前集合的信息熵都是相同的，因此我们只需要最小化回答之后集合的信息熵即可。

  ​         当一个问题提出后，用户的回答将分为两类：肯定和否定。当用户做出肯定或否定的回答后，每个候选宝可梦的确信度将发生不同方向的改变，总体信息熵也因此会发生不同的改变。因此我们要分别考虑肯定、否定两种回答情况，来计算信息熵的期望。

  ​         由于计算候选宝可梦集合的信息熵需要用到候选宝可梦集合中每个宝可梦成为答案的概率，因此我们需要将我们已有的宝可梦确信度分布转化为概率分布，即要将值从区间 $[-1, 1]$ 映射到 $[0, 1]$ 上。这里我想到的是利用 $softmax$ 函数，将确信因子转化为概率：
  $$
  p_i = \frac{e^{cf_i}}{\sum^{n}_{j=1}e^{cf_j}}
  $$
  其中，$cf_i$为第$i$个宝可梦的确信度，$p_i$为第$i$个宝可梦的概率，$n$为宝可梦总数。由此我们得出了当前每一种宝可梦成为答案的概率。

* 问题求解

  对于问题$q_k$，用户做出肯定和否定回答的概率均通过当前的候选宝可梦的概率分布来计算。这里实际上是假设用户总是做出客观真实的判断，因此所有符合问题 $q_k$ 描述的宝可梦的概率之和即为用户做出肯定回答的概率，同理，所有不符合问题 $q_k$ 描述的宝可梦的概率之和即为用户做出否定回答的概率：
  $$
  p\_yes=\sum_{i\ \in\ \{pokemons\ benefit \ from\ q_k\}} p_i
  $$

  $$
  p\_no=\sum_{i\ \notin\ \{pokemons\ benefit \ from\ q_k\}} p_i
  $$

  用户做出肯定回答和否定回答后，候选宝可梦集合S的信息熵分别为：
  $$
  E_{yes}(S)=-\sum^{n}_{i=1}p^{yes}_ilog_2p^{yes}_i
  $$

  $$
  E_{no}(S)=-\sum^{n}_{i=1}p^{no}_ilog_2p^{no}_i
  $$

  其中，$p^{yes}_i$表示接受用户对问题$q_k$的肯定回答后，第$i$个宝可梦的新概率，即由更新后的确信度计算而来的概率；$p^{no}_i$同理为做出否定回答后的新概率。

  最后可以求出进行问题$q_k$的问答后，集合S的信息熵期望为：
  $$
  E_{q_k}(S)=p\_yes\cdot E_{yes}(S) + p\_no\cdot E_{no}(S)
  $$
  对每个问题都进行上述信息熵期望的计算，选取最小化信息熵期望的问题作为下一个问题进行询问：
  $$
  next\_question = argmin_{\ q_k\in questions\_pool}\ E_{q_k}(S)
  $$

* 计算信息熵期望的代码实现

  ```python
      def __calculate_info(self, key, val):
          '''计算信息熵
          '''
          p_yes = 0.0
          p_no = 0.0
          info_yes = 0.0
          info_no = 0.0
          entr_yes = 0.0
          entr_no = 0.0
          
          for poke in self.pokemons.values():
              if poke.have_key_val(key, val): 
                  p_yes += pow(math.e, poke.cf)             # 用户给出Yes回答的概率
              else:
                  p_no += pow(math.e, poke.cf)              # 用户给出No 回答的概率
                  
          for poke in self.pokemons.values():
              new_p = poke.new_cf(key, val, cf=1.0) 
              info_yes += pow(math.e, new_p)
              new_p = poke.new_cf(key, val, cf=-1.0)  
              info_no += pow(math.e, new_p)
          
          for poke in self.pokemons.values():
              new_p = poke.new_cf(key, val, cf=1.0) 
              p = pow(math.e, new_p) / info_yes    # 若用户给出Yes回答后，每个pokemon的概率
              entr_yes -= p * math.log2(p)
              new_p = poke.new_cf(key, val, cf=-1.0)
              p = pow(math.e, new_p) / info_no     # 若用户给出No 回答后，每个pokemon的概率
              entr_no -= p * math.log2(p)
          
          return (entr_yes * p_yes + entr_no * p_no) / (p_yes + p_no + 1e-6)
  ```





## 3  模拟实验

​         为了得到充分多的模拟数据，我先将问答轮数上限调至15，然后通过模拟实验来记录各个宝可梦的确信度变化，从而绘制出各个宝可梦确信度的轨迹图。

我以识别下面这只宝可梦为例：

<img src="/home/river/桌面/Pokemon-Map/report/小火龙.png" style="zoom:15%;" />

识别过程如下：

| 轮数 | 问题                                                 | 用户输入确信度 | 小火龙确信度变化 | 小火马确信度变化 | 迷唇姐确信度变化 | 卡拉卡拉确信度变化 |
| :--: | ---------------------------------------------------- | :------------- | ---------------- | ---------------- | ---------------- | :----------------- |
|  1   | 它一共有4只手和脚吗？                                | 0.98           | +0.392           | +0.392           | +0.392           | +0.392             |
|  2   | 它的眼睛是黑色的吗？                                 | 0.64           | +0.117           | +0.117           | +0.156           | +0.156             |
|  3   | 它是不是生活在森林附近？                             | 0.16           | -0.062           | +0.023           | -0.057           | -0.0               |
|  4   | 它的身体是不是有黄色的部分？                         | -0.64          | +0.106           | +0.09            | +0.098           | +0.087             |
|  5   | 它是不是像一只虫？                                   | -0.9           | -0.0             | -0.0             | -0.0             | -0.0               |
|  6   | 它的身体是不是有粉色的部分？                         | -0.9           | +0.121           | +0.102           | +0.111           | +0.099             |
|  7   | 它的身体是不是有褐色的部分？                         | -0.9           | +0.088           | +0.074           | +0.081           | +0.072             |
|  8   | 它的身体是不是有红色的部分？                         | 0.98           | +0.07            | +0.059           | +0.064           | -0.426             |
|  9   | 它是不是从头顶至尾巴以及四肢上长着燃烧着的火焰鬃毛？ | -0.48          | -0.0             | -0.108           | -0.0             | -0.0               |
|  10  | 它是不是有金色长发？                                 | -0.88          | -0.0             | -0.0             | -0.59            | -                  |
|  11  | 它是不是尾巴上有火焰在燃烧？                         | 0.78           | +0.118           | -0.871           | -                | -                  |
|  12  | 它的身体是不是有橙色的部分？                         | -0.8           | -0.064           | +0.256           | -                | -                  |
|  13  | 它的身体是不是有土色的部分？                         | -0.8           | +0.027           | -                | -                | -                  |
|  14  | 它的身体是不是有绿色的部分？                         | -0.8           | +0.021           | -                | -                | -                  |
|  15  | 它的身体是不是有白色的部分？                         | -0.8           | +0.016           | -                | -                | -                  |

<img src="/home/river/桌面/Pokemon-Map/report/确信度变化轨迹图.png" style="zoom:67%;" />

识别结果最终为——小火龙。经过专家判定，这个识别结果是正确的。实际上上述的其余3只宝可梦为最后才被淘汰出局的3只宝可梦，通过分析它们的确信度变化轨迹，可以得出下面结论：

* 10轮是一个比较良好的问答轮数。在本例中，当问答轮数为10轮时，已经足以判断出答案，此时只剩下小火龙为唯一候选，其余宝可梦均被淘汰；通过大量对不同宝可梦的识别实验，最终发现10轮确实是一个能保证识别准确率的最佳轮数，大部分的识别任务能够在10轮以内就提早完成。若希望以降低准确率为代价提升识别速度，则可设置问答轮数为8轮左右，在本例中，8轮时系统能在识别错误2次以内找到正确答案。
* 系统具有良好的鲁棒性。观察小火龙的确信度变化轨迹，发现其在第2轮后确信度发生了下降，即在第3轮问答中，用户给出了一个错误判断。这个判断给予了小火龙一定的确信度惩罚，但在之后的问答中，这个惩罚很快就被填补上了。这个现象说明了本专家系统有较强的容错性和鲁棒性。
* “细节”特征的判断大幅加快了识别进度。观察迷唇姐的确信度变化轨迹，在第10轮时，由于用户否定了“有金色长发”这一迷唇姐的细节特征，即标志性特征，这直接导致迷唇姐的确信度降低了0.59，并最终出局。其它出局的宝可梦类似。
* ID3算法确实动态选择出了“最有效”的问题。可以看到在第8~11轮问答中，系统挑选的问题使得不正确的宝可梦依次被区分出来并最终出局（在第8轮以前让其余的69只宝可梦出局了），由此可以看出问题的动态选择是成功实现了的。





## 4  其它实现细节

* 知识扩展机制

  本项目加入了知识扩展机制。专家或其他开发人员可以直接通过专家界面输入新增宝可梦的特征到pokemon特征数据库中。前面提过，由于特征数据库隐式地表达了知识库规则和问题集，因此这个专家接口实际上能间接拓展知识库和问题集。

* 用户的模糊化输入

  在用户界面中，用户可以通过一个滑动条模糊地表达对问题的回答。数值从-1到1，直接对应于用户输入的确信度，即从“不是”到“是”，这实际上是受到了模糊逻辑的启发。这样提高了用户的使用体验，也提高了不确定性分析的准确性。

* 解释设备

  当系统给出推测的宝可梦种类时，会将该宝可梦的确信度的变化过程显示出来，并且分别用红色和蓝色代表确信度增益和确信度惩罚，提高了用户体验。

* 容错机制

  系统给出推测结果后，用户可以继续通过滑动条对结果进行肯定或否定。若结果被否定，则系统会按照确信度从大到小依次将候补结果展示出来，直到用户肯定或无候补宝可梦为止。





## 5  效果展示

* 预测皮卡丘

  <img src="/home/river/桌面/Pokemon-Map/report/0.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/1.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/3.png" style="zoom: 50%;" />

  <img src="/home/river/桌面/Pokemon-Map/report/5.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/6.png" style="zoom: 50%;" />

  

* 预测杰尼龟

  <img src="/home/river/桌面/Pokemon-Map/report/11.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/12.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/14.png" style="zoom: 50%;" />

  <img src="/home/river/桌面/Pokemon-Map/report/15.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/16.png" style="zoom: 50%;" />   <img src="/home/river/桌面/Pokemon-Map/report/17.png" style="zoom: 50%;" />

  

* 开发人员界面

  <img src="/home/river/桌面/Pokemon-Map/report/20.png" style="zoom: 50%;" />

  专家等开发人员可以轻松方便地在开发人员界面中输入新增宝可梦的特征信息，从而拓展专家系统的知识库。
  
  



## 6  总结

​         从效果上，我们可以看出本专家系统拥有较好的性能。这一方面得益于不确定性规则设计的严密性，另一方面得益于决策树ID3算法在问题选择上的有效性。而基于框架的设计方法则大幅优化了系统结构，框架的缺省推理特性是本项目知识库的生成基础。

​        从用户体验上，友好的交互界面，模糊化的输入，预测过程的显示以及容错机制都很好地提高了用户的使用体验，让用户得以轻松地与系统进行交互。

​       从扩展性上，知识拓展机制让专家可以通过界面方便的添加新的宝可梦到特征数据库中，这同时拓展了知识库。但需要注意的是，当宝可梦数量更多时，可能意味着需要更多的问答轮数，这就需要开发人员通过模拟实验来调整问答的轮数上限。





## 7  参考文献
[1]周文萱,胡龙桃,张敏,方宇涛,李欣钰.基于YOLO的小型动物识别系统设计[J].计算机时代,2019(03):22-25.

[2]郭雷兵,李炜.动物识别专家系统的程序实现与运行分析[J].长沙电力学院学报(自然科学版),1999(01):29-31.

[3]Mudkip.神奇宝贝百科[DB/OL].wiki.52poke.com,2006.

[4]杜威铭,冉羽.决策树ID3算法研究[J].科技视界,2018(11):145-146+103.